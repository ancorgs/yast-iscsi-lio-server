/*
|***************************************************************************
|
| Copyright (c) [2012] Novell, Inc.
| All Rights Reserved.
|
| This program is free software; you can redistribute it and/or
| modify it under the terms of version 2 of the GNU General Public License as
| published by the Free Software Foundation.
|
| This program is distributed in the hope that it will be useful,
| but WITHOUT ANY WARRANTY; without even the implied warranty of
| MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
| GNU General Public License for more details.
|
| You should have received a copy of the GNU General Public License
| along with this program; if not, contact Novell, Inc.
|
| To contact Novell about this file by physical or electronic mail,
| you may find current contact information at www.novell.com
|
|***************************************************************************
*/
/**
 * File:	modules/IscsiLioServer.ycp
 * Package:	Configuration of iscsi-lio-server
 * Summary:	IscsiLioServer settings, input and output functions
 * Authors:	Thomas Fehr <fehr@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of iscsi-lio-server.
 * Input and output routines.
 */

{

module "IscsiLioServer";
textdomain "iscsi-lio-server";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Service";
import "Package";
import "Popup";
import "SuSEFirewall";
import "Confirm";
import "IscsiLioData";
import "Mode";
import "NetworkService";
import "PackageSystem";
import "Label";

boolean serviceStatus = false;
boolean statusOnStart = false;

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;
global boolean configured = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}



// Settings: Define all variables needed for configuration of iscsi-lio-server
// TODO FIXME: Define all the variables necessary to hold
// TODO FIXME: the configuration here (with the appropriate
// TODO FIXME: description)
// TODO FIXME: For example:
//   /**
//    * List of the configured cards.
//   list cards = [];
//
//   /**
//    * Some additional parameter needed for the configuration.
//   boolean additional_parameter = true;

// read configuration file /etc/ietd.conf
global boolean readConfig(){
 IscsiLioData::SetData( IscsiLioData::ParseConfigLio() );
 return true;
}

// read configuration file /etc/ietd.conf
global map readIetdConfig(){
 map<string, any> read_values =  (map<string, any>)SCR::Read(.etc.ietd.all);
 return IscsiLioData::ParseConfigIetd( read_values );
}

global boolean activateIetdConfig( map ietd ){
 return IscsiLioData::ActivateConfigIetd( ietd );
}


// dummy function since LIO has no config file 
boolean writeConfig(){
 return true;
}

// test if required package ("lio-utils") is installed
boolean installed_packages(){
 if (!PackageSystem::PackageInstalled("lio-utils")){
  y2milestone("Not installed, will install");
  boolean confirm = Popup::AnyQuestionRichText(
        "", _("Can't continue without installing lio-utils package"), 40, 10,
        Label::InstallButton(), Label::CancelButton (), `focus_yes
    );

  if (confirm){
   string service = "tgtd";
   if (Service::Status(service)==0) Service::Stop(service);
   Service::Disable(service);
   service = "iscsitarget";
   if (Service::Status(service)==0) Service::Stop(service);
   Service::Disable(service);
   PackageSystem::DoInstall(["lio-utils"]);
    if (PackageSystem::PackageInstalled("lio-utils")) return true;
	else return false;
  }
  return false;
 } else return true;
}

// check status of target service
// if not enabled, start it manually
boolean getServiceStatus(){
 boolean ret = true;
 if (Service::Status("target") == 0) {
	 statusOnStart=true;
	 serviceStatus=true;
	}
y2milestone("Service status = %1", statusOnStart);
 if (!statusOnStart) 
    {
    if( !Service::Start("target"))
	{
	string txt = sformat( ("Could not start service \"%1\""), 
	                      "/etc/init.d/target" );
	Popup::Error( txt );
	}
    }
 return ret;
}

/**
 * Read all iscsi-lio-server settings
 * @return true on success
 */
global boolean Read() {

    /* IscsiLioServer read dialog caption */
    string caption = _("Initializing iSCSI LIO Target Configuration");

    // TODO FIXME Set the right number of stages
    integer steps = 4;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Read the database"),
	    /* Progress stage 2/3 */
	    _("Read the previous settings"),
	    /* Progress stage 3/3 */
	    _("Detect the devices")
	], [
	    /* Progress step 1/3 */
	    _("Reading the database..."),
	    /* Progress step 2/3 */
	    _("Reading the previous settings..."),
	    /* Progress step 3/3 */
	    _("Detecting the devices..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // check if user is root
    if(!Confirm::MustBeRoot()) return false;
    if(!NetworkService::RunningNetworkPopup()) return false;
    Progress::NextStage();
    // check if required packages ("lio-utils") are installed
    if(!installed_packages()) return false;
    sleep(sl);

    if(Abort()) return false;
    Progress::NextStep();
    // get status of target init script
    if(!getServiceStatus()) return false;
    sleep(sl);

    if(Abort()) return false;
    Progress::NextStage();
    // read configuration (/etc/ietd.conf)
    readConfig();
    if(size(IscsiLioData::GetTargets())==0) 
        {
        map ietd = readIetdConfig();
        string msg = _(
"You have currently no active LIO targets but there seems 
to be a valid config in /etc/ietd.conf. Should the module 
try to import setting from /etc/ietd.conf into LIO?" );
        if( size(ietd["tgt"]:$[])>0 && Report::yesno_message_settings["show"]:true &&
            Popup::YesNo( msg ))
            {
            if( !activateIetdConfig( ietd ))
                {
                string err = _( "Errors during import. Check LIO state!" );
                Report::Error( err );
                }
            }
	}
    sleep(sl);

    // detect devices
        Progress::set(false);
        SuSEFirewall::Read();
        Progress::set(true);

    Progress::NextStage();
    /* Error message */
    if(false) return false;
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    configured = true;
    return true;
}

/**
 * Write all iscsi-lio-server settings
 * @return true on success
 */
global boolean Write() {

    /* IscsiLioServer write dialog caption */
    string caption = _("Saving iSCSI LIO Target Configuration");

    // TODO FIXME And set the right number of stages
    integer steps = 2;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );


        Progress::set(false);
        SuSEFirewall::Write();
        Progress::set(true);

    Progress::NextStage();
    sleep(sl);
    return true;
}

/**
 * Get all iscsi-lio-server settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
 foreach(string key, any value, (map<string, any>)settings, {
  switch(key){
   case("service") :
		serviceStatus = (boolean) value;
		break;
   case("auth")	:
	list<string> incom = [];
	string outgoin = "";
	foreach(map<string, any> row, (list<map<string, any> >)value, {
	 if (row["KEY"]:""=="IncomingUser") incom = add(incom, row["VALUE"]:"");
		else outgoin = row["VALUE"]:"";
	});
        IscsiLioData::SetIetdAuth("",0,incom, outgoin);
        break;
   case("targets") :
	string name = "";
	list<string> lun = [];
	list<string> inc = [];
	string out = "";
	foreach(list< map<string, any> > val, (list<list<map<string, any> > >)value, {
	name="";
	lun=[];
	inc=[];
	out="";
        integer tpg = 1;
	 foreach(map<string, any> row, val, {
	  switch(row["KEY"]:""){
	   case("Target"):
			name = row["VALUE"]:"";
			break;
	   case("Tpg"):
			tpg = tointeger(row["VALUE"]:"1");
                        if( tpg==nil )
                            tpg = 1;
			break;
	   case("Lun"):
			lun = add(lun, row["VALUE"]:"");
			break;
	   case("IncomingUser"):
			inc = add(inc, row["VALUE"]:"");
			break;
	   case("OutgoingUser"):
			out = row["VALUE"]:"";
			break;
	  }
	 });
	 IscsiLioData::AddNewTarget(name, tpg, lun);
	 IscsiLioData::SetIetdAuth(name, tpg, inc, out);
	});
		break;
  }
 });

 configured = true;
    return true;
}

/**
 * Dump the iscsi-lio-server settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
 list targets = [];
 foreach(string k, any v, IscsiLioData::GetExportTargets(), {
  targets = add(targets, v);
 });

 map result = $[
	       "version" : "1.0",
	       "service" : serviceStatus,
	       "auth"	 : IscsiLioData::GetExportAuth("",0),
	       "targets" : targets
 		];
  configured = true;
    return result;
}

string getLunDesc(map<integer,map> lun)
    {
    string ret = "";
    foreach(integer l, map m, lun, 
        {
        if( size(ret)>0 )
            ret = ret + ", ";
        ret = ret + IscsiLioData::GetExportLun( l, m );
        });
    return ret;
    }

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() 
    {
    string summary = _("Configuration summary...");
    if (configured)
        {
	summary = Summary::AddHeader("", _("Global"));
	if (serviceStatus) 
            summary = Summary::AddLine(summary, _("When Booting"));
        else 
            summary = Summary::AddLine(summary, _("Manually"));
	if( !IscsiLioData::HasAuth( "",0,"" )) 
            summary = Summary::AddLine(summary, _("No Authentication"));
	else 
            {
            if(IscsiLioData::HasIncomingAuth("",0,"")) summary = Summary::AddLine(summary, _("Incoming Authentication"));
            if(IscsiLioData::HasOutgoingAuth("",0,"")) summary = Summary::AddLine(summary, _("Outgoing Authentication"));
            }
	summary = Summary::AddHeader(summary, _("Targets"));
	summary = Summary::OpenList(summary);
	foreach(list keys, IscsiLioData::GetTargets(), 
            {
            summary = Summary::AddListItem(summary, keys[0]:"");
            summary = Summary::AddLine(summary, getLunDesc(IscsiLioData::GetLun(keys[0]:"",keys[1]:1)));
            });
	summary = Summary::CloseList(summary);
        } 
    else 
        {
	summary = Summary::NotConfigured();
	}
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ summary, [] ];
    }

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}


// get/set service accessors for CWMService component
global boolean GetStartService() {
 boolean status = Service::Enabled("target");
 y2milestone("target service status %1", status);
 return status;
}

global void SetStartService(boolean status) {
 y2milestone("Set service status %1", status);
 serviceStatus = status;
 if (status == true) Service::Enable("target");
        else Service::Disable("target");
}


/* EOF */
}
